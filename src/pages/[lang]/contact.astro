---
import Base from '../../layouts/Base.astro';
import { t, DEFAULT_LANG, type Lang } from '../../i18n';
import { getCanonicalUrl } from '../../utils/seo';

const lang = (Astro.params.lang as Lang | undefined) ?? DEFAULT_LANG;
const title = t(lang, 'seo_contact_title');
const description = t(lang, 'seo_contact_description');
const url = getCanonicalUrl(lang, '/contact');
const statusMessageTranslations = {
  success: t(lang, 'contact_success'),
  error: t(lang, 'contact_error'),
  network: t(lang, 'contact_network_error'),
};
const privacySlug = lang === 'en' ? 'privacy' : 'privacy';
const privacyPrefix = t(lang, 'contact_privacy_prefix');
const privacyLinkText = t(lang, 'contact_privacy_link');
const privacySuffix = t(lang, 'contact_privacy_suffix');
const needsSpaceBeforeLink = /\S$/.test(privacyPrefix) && !/[’']$/.test(privacyPrefix);
const needsSpaceBeforeSuffix = privacySuffix !== '' && !/^[\s,.;:!?]/.test(privacySuffix);
const recaptchaSiteKey = import.meta.env.PUBLIC_RECAPTCHA_SITE_KEY;
const isRecaptchaEnabled = typeof recaptchaSiteKey === 'string' && recaptchaSiteKey.length > 0;
const recaptchaScriptSrc = isRecaptchaEnabled
  ? `https://www.google.com/recaptcha/api.js?render=${encodeURIComponent(
      recaptchaSiteKey,
    )}&hl=${encodeURIComponent(lang)}`
  : '';
const recaptchaErrorMessage = t(lang, 'contact_recaptcha_error');
---
<Base title={title} description={description} url={url} lang={lang}>
  <section class="mx-auto flex min-h-[calc(100vh-22rem)] max-w-container items-center justify-center px-4 py-10 md:py-16">
    <div class="w-full max-w-xl">
      <h1 class="text-2xl font-extrabold md:text-3xl">{t(lang, 'contact_title')}</h1>

      <form
        id="contactForm"
        class="mt-6 space-y-4"
        novalidate
        data-lang={lang}
        data-status-success={statusMessageTranslations.success}
        data-status-error={statusMessageTranslations.error}
        data-status-network={statusMessageTranslations.network}
        data-status-validation={t(lang, 'contact_validation_error')}
        data-recaptcha-key={isRecaptchaEnabled ? recaptchaSiteKey : undefined}
        data-error-name-required={t(lang, 'contact_name_error_required')}
        data-error-name-invalid={t(lang, 'contact_name_error_invalid')}
        data-error-name-forbidden={t(lang, 'contact_name_error_forbidden')}
        data-error-email-required={t(lang, 'contact_email_error_required')}
        data-error-email-invalid={t(lang, 'contact_email_error_invalid')}
        data-error-email-forbidden={t(lang, 'contact_email_error_forbidden')}
        data-error-message-required={t(lang, 'contact_message_error_required')}
        data-error-message-length={t(lang, 'contact_message_error_length')}
        data-error-message-forbidden={t(lang, 'contact_message_error_forbidden')}
        data-error-consent={t(lang, 'contact_consent_error')}
        data-error-recaptcha={recaptchaErrorMessage}
      >
        <div>
          <label class="mb-1 block text-sm">{t(lang, 'contact_name_label')}</label>
          <input
            name="name"
            required
            class="w-full rounded-md border border-white/10 bg-white/5 px-3 py-2 transition-colors"
          />
          <p data-error-for="name" class="mt-1 hidden text-xs text-red-400" role="alert" aria-live="polite"></p>
        </div>
        <div>
          <label class="mb-1 block text-sm">{t(lang, 'contact_email_label')}</label>
          <input
            type="email"
            name="email"
            required
            class="w-full rounded-md border border-white/10 bg-white/5 px-3 py-2 transition-colors"
          />
          <p data-error-for="email" class="mt-1 hidden text-xs text-red-400" role="alert" aria-live="polite"></p>
        </div>
        <div>
          <label class="mb-1 block text-sm">{t(lang, 'contact_message_label')}</label>
          <textarea
            name="message"
            rows="5"
            required
            class="w-full rounded-md border border-white/10 bg-white/5 px-3 py-2 transition-colors"
          ></textarea>
          <p data-error-for="message" class="mt-1 hidden text-xs text-red-400" role="alert" aria-live="polite"></p>
        </div>

        <!-- RGPD: consentimiento -->
        <div class="flex items-start gap-3" data-error-container="consent">
          <input id="consent" type="checkbox" required class="mt-1 rounded border-white/10 bg-white/5" />
          <label for="consent" class="text-sm text-white/80">
            {privacyPrefix}
            {needsSpaceBeforeLink ? ' ' : ''}
            <a href={`/${lang}/${privacySlug}`} class="underline">
              {privacyLinkText}
            </a>
            {needsSpaceBeforeSuffix ? ' ' : ''}
            {privacySuffix}
          </label>
        </div>
        <p data-error-for="consent" class="hidden text-xs text-red-400" role="alert" aria-live="assertive"></p>

        <!-- Honeypot anti-spam -->
        <input type="text" name="website" class="hidden" autocomplete="off" tabindex="-1" />

        <button
          type="submit"
          class="w-full rounded-md bg-brand-accent px-5 py-3 font-semibold text-black hover:opacity-90 disabled:cursor-not-allowed disabled:opacity-60 sm:w-auto"
        >
          {t(lang, 'contact_submit')}
        </button>

        {isRecaptchaEnabled && (
          <p class="text-xs text-white/60" data-recaptcha-notice>
            {t(lang, 'contact_recaptcha_notice')}
          </p>
        )}

        <p id="msg" role="status" class="mt-2 text-sm text-white/70"></p>
      </form>
    </div>
  </section>

  {isRecaptchaEnabled && <script src={recaptchaScriptSrc} defer></script>}

  <script is:inline>
    const form = document.getElementById('contactForm');
    const statusEl = document.getElementById('msg');

    if (!(form instanceof HTMLFormElement) || !(statusEl instanceof HTMLElement)) {
      console.warn('Contact form markup missing, aborting behaviour.');
    } else {
      const currentLang = form.dataset.lang ?? 'es';
      const statusMessages = {
        success: form.dataset.statusSuccess ?? '',
        error: form.dataset.statusError ?? '',
        network: form.dataset.statusNetwork ?? '',
        validation: form.dataset.statusValidation ?? '',
      };
      const submitButton = form.querySelector('button[type="submit"]');
      const recaptchaSiteKey = form.dataset.recaptchaKey ?? '';
      const recaptchaNotice = form.querySelector('[data-recaptcha-notice]');
      const getRecaptchaApi = () => window.grecaptcha?.enterprise ?? window.grecaptcha ?? null;
      const errorElements = new Map();
      form.querySelectorAll('[data-error-for]').forEach((element) => {
        const key = element.getAttribute('data-error-for');
        if (key) {
          errorElements.set(key, element);
        }
      });

      const toggleError = (key, message, control) => {
        const errorElement = errorElements.get(key);
        if (!(errorElement instanceof HTMLElement)) {
          return;
        }

        const hasMessage = typeof message === 'string' && message.length > 0;
        errorElement.textContent = hasMessage ? message : '';
        errorElement.classList.toggle('hidden', !hasMessage);
        errorElement.setAttribute('aria-hidden', hasMessage ? 'false' : 'true');

        if (control instanceof HTMLElement) {
          const isInput = control instanceof HTMLInputElement || control instanceof HTMLTextAreaElement;
          if (isInput) {
            control.setAttribute('aria-invalid', hasMessage ? 'true' : 'false');
            control.classList.toggle('border-red-500', hasMessage);
          }
        }
      };

      const consentContainer = form.querySelector('[data-error-container="consent"]');
      const getMessage = (key) => form.dataset[key] ?? '';

      const markRecaptchaNoticeError = (hasError) => {
        if (recaptchaNotice instanceof HTMLElement) {
          recaptchaNotice.classList.toggle('text-red-400', hasError);
        }
      };

      const executeRecaptchaAction = (action = 'contact_form') =>
        new Promise((resolve, reject) => {
          if (!recaptchaSiteKey) {
            resolve('');
            return;
          }

          const grecaptchaApi = getRecaptchaApi();

          if (!grecaptchaApi || typeof grecaptchaApi.execute !== 'function') {
            reject(new Error('grecaptcha.execute no está disponible'));
            return;
          }

          const ready = typeof grecaptchaApi.ready === 'function'
            ? grecaptchaApi.ready.bind(grecaptchaApi)
            : (fn) => fn();

          ready(() => {
            Promise.resolve(
              grecaptchaApi.execute(recaptchaSiteKey, { action: typeof action === 'string' ? action : 'contact_form' })
            )
              .then((token) => resolve(typeof token === 'string' ? token : ''))
              .catch(reject);
          });
        });

      const containsForbiddenContent = (value) => {
        if (!value) {
          return false;
        }

        const forbiddenPatterns = [
          /(https?:\/\/|ftp:\/\/|www\.)/i,
          /(\.{1,2}[\\/])/, // ./ or ../
          /(^|[\s])[A-Za-z]:\\/i,
          /(^|[\s@])[A-Za-z0-9._-]{2,}[\\/][A-Za-z0-9._-]{2,}/,
        ];

        return forbiddenPatterns.some((pattern) => pattern.test(value));
      };

      const fields = {
        name: form.elements.namedItem('name'),
        email: form.elements.namedItem('email'),
        message: form.elements.namedItem('message'),
        consent: form.querySelector('#consent'),
      };

      const ensureField = (field) =>
        field instanceof HTMLInputElement || field instanceof HTMLTextAreaElement ? field : null;
      const ensureCheckbox = (field) =>
        field instanceof HTMLInputElement && field.type === 'checkbox' ? field : null;

      const validators = {
        name: () => {
          const input = ensureField(fields.name);
          if (!input) {
            return true;
          }

          const value = input.value.trim();
          if (!value) {
            toggleError('name', getMessage('errorNameRequired'), input);
            return false;
          }

          if (value.length < 2 || value.length > 200) {
            toggleError('name', getMessage('errorNameInvalid'), input);
            return false;
          }

          if (/\d/.test(value) || !/^[-'\p{L}\p{M}\s]+$/u.test(value)) {
            toggleError('name', getMessage('errorNameInvalid'), input);
            return false;
          }

          if (containsForbiddenContent(value)) {
            toggleError('name', getMessage('errorNameForbidden'), input);
            return false;
          }

          toggleError('name', '', input);
          return true;
        },
        email: () => {
          const input = ensureField(fields.email);
          if (!input) {
            return true;
          }

          const value = input.value.trim();
          if (!value) {
            toggleError('email', getMessage('errorEmailRequired'), input);
            return false;
          }

          if (!input.checkValidity()) {
            toggleError('email', getMessage('errorEmailInvalid'), input);
            return false;
          }

          if (containsForbiddenContent(value)) {
            toggleError('email', getMessage('errorEmailForbidden'), input);
            return false;
          }

          toggleError('email', '', input);
          return true;
        },
        message: () => {
          const input = ensureField(fields.message);
          if (!input) {
            return true;
          }

          const value = input.value.trim();
          if (!value) {
            toggleError('message', getMessage('errorMessageRequired'), input);
            return false;
          }

          if (value.length < 10 || value.length > 5000) {
            toggleError('message', getMessage('errorMessageLength'), input);
            return false;
          }

          if (containsForbiddenContent(value)) {
            toggleError('message', getMessage('errorMessageForbidden'), input);
            return false;
          }

          toggleError('message', '', input);
          return true;
        },
        consent: () => {
          const checkbox = ensureCheckbox(fields.consent);
          if (!checkbox) {
            return true;
          }

          if (!checkbox.checked) {
            toggleError('consent', getMessage('errorConsent'), checkbox);
            consentContainer?.classList.add('text-red-400');
            return false;
          }

          toggleError('consent', '', checkbox);
          consentContainer?.classList.remove('text-red-400');
          return true;
        },
      };

      const validatorKeys = Object.keys(validators);

      const validateAll = () => {
        let firstInvalidControl;
        const results = validatorKeys.map((key) => {
          const isValid = validators[key]();
          if (!isValid && !firstInvalidControl) {
            const field = fields[key];
            if (field instanceof HTMLElement) {
              firstInvalidControl = field;
            }
          }
          return isValid;
        });

        if (firstInvalidControl instanceof HTMLElement) {
          firstInvalidControl.focus({ preventScroll: false });
        }

        return results.every(Boolean);
      };

      const clearAllErrors = () => {
        validatorKeys.forEach((key) => {
          const field = fields[key];
          if (field instanceof HTMLInputElement || field instanceof HTMLTextAreaElement) {
            toggleError(key, '', field);
          } else {
            toggleError(key, '', undefined);
          }
        });
        consentContainer?.classList.remove('text-red-400');
      };

      Object.entries(fields).forEach(([key, field]) => {
        if (field instanceof HTMLInputElement || field instanceof HTMLTextAreaElement) {
          field.addEventListener('input', () => {
            validators[key]?.();
          });
          field.addEventListener('blur', () => {
            validators[key]?.();
          });
        }
      });

      if (fields.consent instanceof HTMLInputElement) {
        fields.consent.addEventListener('change', () => {
          validators.consent();
        });
      }

      const showRecaptchaError = () => {
        markRecaptchaNoticeError(true);
        statusEl.textContent = getMessage('errorRecaptcha') || statusMessages.validation;
        statusEl.classList.add('text-red-400');
      };

      if (recaptchaSiteKey) {
        markRecaptchaNoticeError(false);
      }

      form.addEventListener('submit', async (event) => {
        event.preventDefault();

        if (!validateAll()) {
          statusEl.textContent = statusMessages.validation;
          statusEl.classList.add('text-red-400');
          return;
        }

        statusEl.classList.remove('text-red-400');
        const formData = new FormData(form);
        const honeypotValue = formData.get('website');

        if (typeof honeypotValue === 'string' && honeypotValue.trim().length > 0) {
          console.warn('Formulario marcado como spam por el honeypot.');
          form.reset();
          clearAllErrors();
          statusEl.textContent = statusMessages.success;
          return;
        }

        const entries = Object.fromEntries(formData.entries());
        const serialised = Object.fromEntries(
          Object.entries(entries).map(([key, value]) => [key, typeof value === 'string' ? value : ''])
        );
        delete serialised.website;

        if (submitButton instanceof HTMLButtonElement) {
          submitButton.disabled = true;
          submitButton.dataset.loading = 'true';
        }

        statusEl.textContent = '';

        let recaptchaToken;

        if (recaptchaSiteKey) {
          try {
            recaptchaToken = await executeRecaptchaAction('contact_form');
          } catch (err) {
            console.error('No se pudo obtener el token de reCAPTCHA', err);
            showRecaptchaError();

            if (submitButton instanceof HTMLButtonElement) {
              submitButton.disabled = false;
              delete submitButton.dataset.loading;
            }

            return;
          }

          if (!recaptchaToken) {
            showRecaptchaError();

            if (submitButton instanceof HTMLButtonElement) {
              submitButton.disabled = false;
              delete submitButton.dataset.loading;
            }

            return;
          }

          markRecaptchaNoticeError(false);
          statusEl.classList.remove('text-red-400');
          statusEl.textContent = '';
        }

        const body = { ...serialised, lang: currentLang, token: recaptchaToken };
        try {
          const response = await fetch('/api/contact', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
          });

          let result = null;

          try {
            result = await response.json();
          } catch (jsonError) {
            console.warn('Respuesta no JSON desde /api/contact', jsonError);
          }

          if (response.ok && result?.ok) {
            statusEl.textContent = statusMessages.success;
            form.reset();
            clearAllErrors();
            statusEl.classList.remove('text-red-400');
          } else {
            const errorMessage =
              (result && typeof result.error === 'string' && result.error.length > 0)
                ? result.error
                : statusMessages.error;
            statusEl.textContent = errorMessage;
            statusEl.classList.add('text-red-400');

            if (recaptchaSiteKey) {
              showRecaptchaError();
            }
          }
        } catch (err) {
          console.error('Error enviando formulario de contacto', err);
          statusEl.textContent = statusMessages.network;
          statusEl.classList.add('text-red-400');
        } finally {
          if (submitButton instanceof HTMLButtonElement) {
            submitButton.disabled = false;
            delete submitButton.dataset.loading;
          }
        }
      });
    }
  </script>
</Base>