---
import Base from '../../layouts/Base.astro';
import { t, DEFAULT_LANG, type Lang } from '../../i18n';

const lang = (Astro.params.lang as Lang | undefined) ?? DEFAULT_LANG;
const statusMessageTranslations = {
  success: t(lang, 'contact_success'),
  error: t(lang, 'contact_error'),
  network: t(lang, 'contact_network_error'),
};
const privacySlug = lang === 'en' ? 'privacy' : 'privacy';
const privacyPrefix = t(lang, 'contact_privacy_prefix');
const privacyLinkText = t(lang, 'contact_privacy_link');
const privacySuffix = t(lang, 'contact_privacy_suffix');
const needsSpaceBeforeLink = /\S$/.test(privacyPrefix) && !/[’']$/.test(privacyPrefix);
const needsSpaceBeforeSuffix = privacySuffix !== '' && !/^[\s,.;:!?]/.test(privacySuffix);
const recaptchaSiteKey = import.meta.env.PUBLIC_RECAPTCHA_SITE_KEY;
const isRecaptchaEnabled = typeof recaptchaSiteKey === 'string' && recaptchaSiteKey.length > 0;
---
<Base title={`Auris — ${t(lang, 'nav_contact')}`} lang={lang}>
  <section class="mx-auto max-w-container px-4 py-10 md:py-16">
    <h1 class="text-2xl mx-auto md:text-3xl font-extrabold text-center">{t(lang, 'contact_title')}</h1>
    
    <form
      id="contactForm"
      class="mt-6 max-w-xl mx-auto space-y-4"
      novalidate
      data-lang={lang}
      data-status-success={statusMessageTranslations.success}
      data-status-error={statusMessageTranslations.error}
      data-status-network={statusMessageTranslations.network}
      data-status-validation={t(lang, 'contact_validation_error')}
      data-recaptcha-key={isRecaptchaEnabled ? recaptchaSiteKey : undefined}
      data-error-name-required={t(lang, 'contact_name_error_required')}
      data-error-name-invalid={t(lang, 'contact_name_error_invalid')}
      data-error-name-forbidden={t(lang, 'contact_name_error_forbidden')}
      data-error-email-required={t(lang, 'contact_email_error_required')}
      data-error-email-invalid={t(lang, 'contact_email_error_invalid')}
      data-error-email-forbidden={t(lang, 'contact_email_error_forbidden')}
      data-error-message-required={t(lang, 'contact_message_error_required')}
      data-error-message-length={t(lang, 'contact_message_error_length')}
      data-error-message-forbidden={t(lang, 'contact_message_error_forbidden')}
      data-error-consent={t(lang, 'contact_consent_error')}
    >
      <div>
        <label class="block text-sm mb-1">{t(lang, 'contact_name_label')}</label>
        <input name="name" required class="w-full rounded-md bg-white/5 border border-white/10 px-3 py-2 transition-colors" />
        <p data-error-for="name" class="text-xs text-red-400 mt-1 hidden" role="alert" aria-live="polite"></p>
      </div>
      <div>
        <label class="block text-sm mb-1">{t(lang, 'contact_email_label')}</label>
        <input type="email" name="email" required class="w-full rounded-md bg-white/5 border border-white/10 px-3 py-2 transition-colors" />
        <p data-error-for="email" class="text-xs text-red-400 mt-1 hidden" role="alert" aria-live="polite"></p>
      </div>
      <div>
        <label class="block text-sm mb-1">{t(lang, 'contact_message_label')}</label>
        <textarea name="message" rows="5" required class="w-full rounded-md bg-white/5 border border-white/10 px-3 py-2 transition-colors"></textarea>
        <p data-error-for="message" class="text-xs text-red-400 mt-1 hidden" role="alert" aria-live="polite"></p>
      </div>

      <!-- RGPD: consentimiento -->
      <div class="flex items-start gap-3" data-error-container="consent">
        <input id="consent" type="checkbox" required class="mt-1 rounded bg-white/5 border-white/10" />
        <label for="consent" class="text-sm text-white/80">
          {privacyPrefix}
          {needsSpaceBeforeLink ? ' ' : ''}
          <a href={`/${lang}/${privacySlug}`} class="underline">
            {privacyLinkText}
          </a>
          {needsSpaceBeforeSuffix ? ' ' : ''}
          {privacySuffix}
        </label>
      </div>
      <p data-error-for="consent" class="text-xs text-red-400 hidden" role="alert" aria-live="assertive"></p>
  <section class="mx-auto flex min-h-[calc(100vh-22rem)] max-w-container items-center justify-center px-4 py-10 md:py-16">
    <div class="w-full max-w-xl">
      <h1 class="text-2xl font-extrabold md:text-3xl">{t(lang, 'contact_title')}</h1>

      <form
        id="contactForm"
        class="mt-6 space-y-4"
        novalidate
        data-lang={lang}
        data-status-success={statusMessageTranslations.success}
        data-status-error={statusMessageTranslations.error}
        data-status-network={statusMessageTranslations.network}
      >
        <div>
          <label class="mb-1 block text-sm">{t(lang, 'contact_name_label')}</label>
          <input name="name" required class="w-full rounded-md border border-white/10 bg-white/5 px-3 py-2" />
        </div>
        <div>
          <label class="mb-1 block text-sm">{t(lang, 'contact_email_label')}</label>
          <input type="email" name="email" required class="w-full rounded-md border border-white/10 bg-white/5 px-3 py-2" />
        </div>
        <div>
          <label class="mb-1 block text-sm">{t(lang, 'contact_message_label')}</label>
          <textarea name="message" rows="5" required class="w-full rounded-md border border-white/10 bg-white/5 px-3 py-2"></textarea>
        </div>

        <!-- RGPD: consentimiento -->
        <div class="flex items-start gap-3">
          <input id="consent" type="checkbox" required class="mt-1 rounded border-white/10 bg-white/5" />
          <label for="consent" class="text-sm text-white/80">
            {privacyPrefix}
            {needsSpaceBeforeLink ? ' ' : ''}
            <a href={`/${lang}/${privacySlug}`} class="underline">
              {privacyLinkText}
            </a>
            {needsSpaceBeforeSuffix ? ' ' : ''}
            {privacySuffix}
          </label>
        </div>

        <!-- Honeypot anti-spam -->
        <input type="text" name="website" style="display:none" autocomplete="off" />

      <button class="w-full sm:w-auto rounded-md bg-brand-accent text-black font-semibold px-5 py-3 hover:opacity-90">
        {t(lang, 'contact_submit')}
      </button>

      {isRecaptchaEnabled && (
        <p class="text-xs text-white/60" data-recaptcha-notice>
          {t(lang, 'contact_recaptcha_notice')}
        </p>
      )}

      <p id="msg" role="status" class="text-sm text-white/70 mt-2"></p>
    </form>
        <button class="w-full rounded-md bg-brand-accent px-5 py-3 font-semibold text-black hover:opacity-90 sm:w-auto">
          {t(lang,'cta_primary')}
        </button>

        <p id="msg" role="status" class="mt-2 text-sm text-white/70"></p>
      </form>
    </div>
  </section>

  {isRecaptchaEnabled && (
    <script src={`https://www.google.com/recaptcha/api.js?render=${encodeURIComponent(recaptchaSiteKey)}`} async defer></script>
  )}

  <script is:inline>
    const form = document.getElementById('contactForm');
    const statusEl = document.getElementById('msg');

    if (!(form instanceof HTMLFormElement) || !(statusEl instanceof HTMLElement)) {
      console.warn('Contact form markup missing, aborting behaviour.');
    } else {
      const currentLang = form.dataset.lang ?? 'es';
      const statusMessages = {
        success: form.dataset.statusSuccess ?? '',
        error: form.dataset.statusError ?? '',
        network: form.dataset.statusNetwork ?? '',
        validation: form.dataset.statusValidation ?? '',
      };
      const submitButton = form.querySelector('button[type="submit"]');
      const recaptchaSiteKey = form.dataset.recaptchaKey ?? '';

      const errorElements = new Map();
      form.querySelectorAll('[data-error-for]').forEach((element) => {
        const key = element.getAttribute('data-error-for');
        if (key) {
          errorElements.set(key, element);
        }
      });

      const toggleError = (key, message, control) => {
        const errorElement = errorElements.get(key);
        if (!(errorElement instanceof HTMLElement)) {
          return;
        }

        const hasMessage = typeof message === 'string' && message.length > 0;
        errorElement.textContent = hasMessage ? message : '';
        errorElement.classList.toggle('hidden', !hasMessage);
        errorElement.setAttribute('aria-hidden', hasMessage ? 'false' : 'true');

        if (control instanceof HTMLElement) {
          const isInput = control instanceof HTMLInputElement || control instanceof HTMLTextAreaElement;
          if (isInput) {
            control.setAttribute('aria-invalid', hasMessage ? 'true' : 'false');
            control.classList.toggle('border-red-500', hasMessage);
          }
        }
      };

      const consentContainer = form.querySelector('[data-error-container="consent"]');

      const getMessage = (key) => form.dataset[key] ?? '';

      const containsForbiddenContent = (value) => {
        if (!value) {
          return false;
        }

        const forbiddenPatterns = [
          /(https?:\/\/|ftp:\/\/|www\.)/i,
          /(\.{1,2}[\\/])/, // ./ or ../
          /(^|[\s])[A-Za-z]:\\/i,
          /(^|[\s@])[A-Za-z0-9._-]{2,}[\\/][A-Za-z0-9._-]{2,}/,
        ];

        return forbiddenPatterns.some((pattern) => pattern.test(value));
      };

      const fields = {
        name: form.elements.namedItem('name'),
        email: form.elements.namedItem('email'),
        message: form.elements.namedItem('message'),
        consent: form.querySelector('#consent'),
      };

      const ensureField = (field) => (field instanceof HTMLInputElement || field instanceof HTMLTextAreaElement ? field : null);
      const ensureCheckbox = (field) => (field instanceof HTMLInputElement && field.type === 'checkbox' ? field : null);

      const validators = {
        name: () => {
          const input = ensureField(fields.name);
          if (!input) {
            return true;
          }

          const value = input.value.trim();
          if (!value) {
            toggleError('name', getMessage('errorNameRequired'), input);
            return false;
          }

          if (value.length < 2 || value.length > 200) {
            toggleError('name', getMessage('errorNameInvalid'), input);
            return false;
          }

          if (/\d/.test(value) || !/^[-'\p{L}\p{M}\s]+$/u.test(value)) {
            toggleError('name', getMessage('errorNameInvalid'), input);
            return false;
          }

          if (containsForbiddenContent(value)) {
            toggleError('name', getMessage('errorNameForbidden'), input);
            return false;
          }

          toggleError('name', '', input);
          return true;
        },
        email: () => {
          const input = ensureField(fields.email);
          if (!input) {
            return true;
          }

          const value = input.value.trim();
          if (!value) {
            toggleError('email', getMessage('errorEmailRequired'), input);
            return false;
          }

          if (!input.checkValidity()) {
            toggleError('email', getMessage('errorEmailInvalid'), input);
            return false;
          }

          if (containsForbiddenContent(value)) {
            toggleError('email', getMessage('errorEmailForbidden'), input);
            return false;
          }

          toggleError('email', '', input);
          return true;
        },
        message: () => {
          const input = ensureField(fields.message);
          if (!input) {
            return true;
          }

          const value = input.value.trim();
          if (!value) {
            toggleError('message', getMessage('errorMessageRequired'), input);
            return false;
          }

          if (value.length < 10 || value.length > 5000) {
            toggleError('message', getMessage('errorMessageLength'), input);
            return false;
          }

          if (containsForbiddenContent(value)) {
            toggleError('message', getMessage('errorMessageForbidden'), input);
            return false;
          }

          toggleError('message', '', input);
          return true;
        },
        consent: () => {
          const checkbox = ensureCheckbox(fields.consent);
          if (!checkbox) {
            return true;
          }

          if (!checkbox.checked) {
            toggleError('consent', getMessage('errorConsent'), checkbox);
            consentContainer?.classList.add('text-red-400');
            return false;
          }

          toggleError('consent', '', checkbox);
          consentContainer?.classList.remove('text-red-400');
          return true;
        },
      };

      const validatorKeys = Object.keys(validators);

      const validateAll = () => {
        let firstInvalidControl;
        const results = validatorKeys.map((key) => {
          const isValid = validators[key]();
          if (!isValid && !firstInvalidControl) {
            const field = fields[key];
            if (field instanceof HTMLElement) {
              firstInvalidControl = field;
            }
          }
          return isValid;
        });

        if (firstInvalidControl instanceof HTMLElement) {
          firstInvalidControl.focus({ preventScroll: false });
        }

        return results.every(Boolean);
      };

      const clearAllErrors = () => {
        validatorKeys.forEach((key) => {
          const field = fields[key];
          if (field instanceof HTMLInputElement || field instanceof HTMLTextAreaElement) {
            toggleError(key, '', field);
          } else {
            toggleError(key, '', undefined);
          }
        });
        consentContainer?.classList.remove('text-red-400');
      };

      Object.entries(fields).forEach(([key, field]) => {
        if (field instanceof HTMLInputElement || field instanceof HTMLTextAreaElement) {
          field.addEventListener('input', () => {
            validators[key]?.();
          });
          field.addEventListener('blur', () => {
            validators[key]?.();
          });
        }
      });

      if (fields.consent instanceof HTMLInputElement) {
        fields.consent.addEventListener('change', () => {
          validators.consent();
        });
      }

      const executeRecaptcha = (siteKey) =>
        new Promise((resolve, reject) => {
          if (!siteKey) {
            resolve(undefined);
            return;
          }

          let attempts = 0;
          const maxAttempts = 50; // ~5s esperando a que cargue el script

          const attemptExecution = () => {
            attempts += 1;
            const grecaptcha = window.grecaptcha;

            if (!grecaptcha || typeof grecaptcha.ready !== 'function') {
              if (attempts >= maxAttempts) {
                reject(new Error('reCAPTCHA no se ha cargado a tiempo'));
                return;
              }

              setTimeout(attemptExecution, 100);
              return;
            }

            grecaptcha.ready(() => {
              grecaptcha
                .execute(siteKey, { action: 'contact_form' })
                .then((token) => {
                  if (typeof token === 'string' && token) {
                    resolve(token);
                  } else {
                    reject(new Error('Token de reCAPTCHA inválido'));
                  }
                })
                .catch(reject);
            });
          };

          attemptExecution();
        });

      form.addEventListener('submit', async (event) => {
        event.preventDefault();

        if (!validateAll()) {
          statusEl.textContent = statusMessages.validation;
          statusEl.classList.add('text-red-400');
          return;
        }

        statusEl.classList.remove('text-red-400');
        const formData = new FormData(form);
        const entries = Object.fromEntries(formData.entries());
        const serialised = Object.fromEntries(
          Object.entries(entries).map(([key, value]) => [key, typeof value === 'string' ? value : ''])
        );

        if (submitButton instanceof HTMLButtonElement) {
          submitButton.disabled = true;
          submitButton.dataset.loading = 'true';
        }

        statusEl.textContent = '';

        let recaptchaToken;

        try {
          recaptchaToken = await executeRecaptcha(recaptchaSiteKey);
        } catch (err) {
          console.error('Error resolviendo reCAPTCHA', err);
          statusEl.textContent = statusMessages.network;

          if (submitButton instanceof HTMLButtonElement) {
            submitButton.disabled = false;
            delete submitButton.dataset.loading;
          }

          return;
        }

        const body = { ...serialised, lang: currentLang, token: recaptchaToken };


        try {
          const response = await fetch('/api/contact', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
          });

          const result = await response.json();

          if (response.ok && result.ok) {
            statusEl.textContent = statusMessages.success;
            form.reset();
            clearAllErrors();
          } else {
            statusEl.textContent = result.error || statusMessages.error;
          }
        } catch (err) {
          console.error('Error enviando formulario de contacto', err);
          statusEl.textContent = statusMessages.network;
        } finally {
          if (submitButton instanceof HTMLButtonElement) {
            submitButton.disabled = false;
            delete submitButton.dataset.loading;
          }
        }
      });
    }
  </script>
</Base>