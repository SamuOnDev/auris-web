---
import Base from '../../layouts/Base.astro';
import { t, DEFAULT_LANG, type Lang } from '../../i18n';

const lang = (Astro.params.lang as Lang | undefined) ?? DEFAULT_LANG;
const statusMessageTranslations = {
  success: t(lang, 'contact_success'),
  error: t(lang, 'contact_error'),
  network: t(lang, 'contact_network_error'),
};
const privacySlug = lang === 'en' ? 'privacy' : 'privacy';
const privacyPrefix = t(lang, 'contact_privacy_prefix');
const privacyLinkText = t(lang, 'contact_privacy_link');
const privacySuffix = t(lang, 'contact_privacy_suffix');
const needsSpaceBeforeLink = /\S$/.test(privacyPrefix) && !/[’']$/.test(privacyPrefix);
const needsSpaceBeforeSuffix = privacySuffix !== '' && !/^[\s,.;:!?]/.test(privacySuffix);
const recaptchaSiteKey = import.meta.env.PUBLIC_RECAPTCHA_SITE_KEY;
const isRecaptchaEnabled = typeof recaptchaSiteKey === 'string' && recaptchaSiteKey.length > 0;
---
<Base title={`Auris — ${t(lang, 'nav_contact')}`} lang={lang}>
  <section class="mx-auto flex min-h-[calc(100vh-22rem)] max-w-container items-center justify-center px-4 py-10 md:py-16">
    <div class="w-full max-w-xl">
      <h1 class="text-2xl font-extrabold md:text-3xl">{t(lang, 'contact_title')}</h1>

      <form
        id="contactForm"
        class="mt-6 space-y-4"
        novalidate
        data-lang={lang}
        data-status-success={statusMessageTranslations.success}
        data-status-error={statusMessageTranslations.error}
        data-status-network={statusMessageTranslations.network}
        data-status-validation={t(lang, 'contact_validation_error')}
        data-recaptcha-key={isRecaptchaEnabled ? recaptchaSiteKey : undefined}
        data-error-name-required={t(lang, 'contact_name_error_required')}
        data-error-name-invalid={t(lang, 'contact_name_error_invalid')}
        data-error-name-forbidden={t(lang, 'contact_name_error_forbidden')}
        data-error-email-required={t(lang, 'contact_email_error_required')}
        data-error-email-invalid={t(lang, 'contact_email_error_invalid')}
        data-error-email-forbidden={t(lang, 'contact_email_error_forbidden')}
        data-error-message-required={t(lang, 'contact_message_error_required')}
        data-error-message-length={t(lang, 'contact_message_error_length')}
        data-error-message-forbidden={t(lang, 'contact_message_error_forbidden')}
        data-error-consent={t(lang, 'contact_consent_error')}
      >
        <div>
          <label class="mb-1 block text-sm">{t(lang, 'contact_name_label')}</label>
          <input
            name="name"
            required
            class="w-full rounded-md border border-white/10 bg-white/5 px-3 py-2 transition-colors"
          />
          <p data-error-for="name" class="mt-1 hidden text-xs text-red-400" role="alert" aria-live="polite"></p>
        </div>
        <div>
          <label class="mb-1 block text-sm">{t(lang, 'contact_email_label')}</label>
          <input
            type="email"
            name="email"
            required
            class="w-full rounded-md border border-white/10 bg-white/5 px-3 py-2 transition-colors"
          />
          <p data-error-for="email" class="mt-1 hidden text-xs text-red-400" role="alert" aria-live="polite"></p>
        </div>
        <div>
          <label class="mb-1 block text-sm">{t(lang, 'contact_message_label')}</label>
          <textarea
            name="message"
            rows="5"
            required
            class="w-full rounded-md border border-white/10 bg-white/5 px-3 py-2 transition-colors"
          ></textarea>
          <p data-error-for="message" class="mt-1 hidden text-xs text-red-400" role="alert" aria-live="polite"></p>
        </div>

        <!-- RGPD: consentimiento -->
        <div class="flex items-start gap-3" data-error-container="consent">
          <input id="consent" type="checkbox" required class="mt-1 rounded border-white/10 bg-white/5" />
          <label for="consent" class="text-sm text-white/80">
            {privacyPrefix}
            {needsSpaceBeforeLink ? ' ' : ''}
            <a href={`/${lang}/${privacySlug}`} class="underline">
              {privacyLinkText}
            </a>
            {needsSpaceBeforeSuffix ? ' ' : ''}
            {privacySuffix}
          </label>
        </div>
        <p data-error-for="consent" class="hidden text-xs text-red-400" role="alert" aria-live="assertive"></p>

        <!-- Honeypot anti-spam -->
        <input type="text" name="website" class="hidden" autocomplete="off" tabindex="-1" />

        <button
          type="submit"
          class="w-full rounded-md bg-brand-accent px-5 py-3 font-semibold text-black hover:opacity-90 sm:w-auto"
        >
          Enviar
        </button>

        {isRecaptchaEnabled && (
          <p class="text-xs text-white/60" data-recaptcha-notice>
            {t(lang, 'contact_recaptcha_notice')}
          </p>
        )}

        <p id="msg" role="status" class="mt-2 text-sm text-white/70"></p>
      </form>
    </div>
  </section>

  {isRecaptchaEnabled && (
    <script src={`https://www.google.com/recaptcha/api.js?render=${encodeURIComponent(recaptchaSiteKey)}`} async defer></script>
  )}

  <script is:inline>
    const form = document.getElementById('contactForm');
    const statusEl = document.getElementById('msg');

    if (!(form instanceof HTMLFormElement) || !(statusEl instanceof HTMLElement)) {
      console.warn('Contact form markup missing, aborting behaviour.');
    } else {
      const currentLang = form.dataset.lang ?? 'es';
      const statusMessages = {
        success: form.dataset.statusSuccess ?? '',
        error: form.dataset.statusError ?? '',
        network: form.dataset.statusNetwork ?? '',
        validation: form.dataset.statusValidation ?? '',
      };
      const submitButton = form.querySelector('button[type="submit"]');
      const recaptchaSiteKey = form.dataset.recaptchaKey ?? '';
      const isRecaptchaEnabled = typeof recaptchaSiteKey === 'string' && recaptchaSite
                .then((token) => {
                  if (typeof token === 'string' && token) {
                    resolve(token);
                  } else {
                    reject(new Error('Token de reCAPTCHA inválido'));
                  }
                })
                .catch(reject);
            });
          };

          attemptExecution();
        });

      form.addEventListener('submit', async (event) => {
        event.preventDefault();

        if (!validateAll()) {
          statusEl.textContent = statusMessages.validation;
          statusEl.classList.add('text-red-400');
          return;
        }

        statusEl.classList.remove('text-red-400');
        const formData = new FormData(form);
        const honeypotValue = formData.get('website');

        if (typeof honeypotValue === 'string' && honeypotValue.trim().length > 0) {
          console.warn('Formulario marcado como spam por el honeypot.');
          form.reset();
          clearAllErrors();
          statusEl.textContent = statusMessages.success;
          return;
        }

        const entries = Object.fromEntries(formData.entries());
        const serialised = Object.fromEntries(
          Object.entries(entries).map(([key, value]) => [key, typeof value === 'string' ? value : ''])
        );
        delete serialised.website;

        if (submitButton instanceof HTMLButtonElement) {
          submitButton.disabled = true;
          submitButton.dataset.loading = 'true';
        }

        statusEl.textContent = '';

        let recaptchaToken;

        try {
          recaptchaToken = await executeRecaptcha(recaptchaSiteKey);
        } catch (err) {
          console.error('Error resolviendo reCAPTCHA', err);
          statusEl.textContent = statusMessages.network;

          if (submitButton instanceof HTMLButtonElement) {
            submitButton.disabled = false;
            delete submitButton.dataset.loading;
          }

          return;
        }

        const body = { ...serialised, lang: currentLang, token: recaptchaToken };
        const isRecaptchaEnabled = typeof recaptchaSiteKey === 'string' && recaptchaSite
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
          });

          const result = await response.json();

          if (response.ok && result.ok) {
            statusEl.textContent = statusMessages.success;
            form.reset();
            clearAllErrors();
          } else {
            statusEl.textContent = result.error || statusMessages.error;
          }
        } catch (err) {
          console.error('Error enviando formulario de contacto', err);
          statusEl.textContent = statusMessages.network;
        } finally {
          if (submitButton instanceof HTMLButtonElement) {
            submitButton.disabled = false;
            delete submitButton.dataset.loading;
          }
        }
      });
    }
  </script>
</Base>